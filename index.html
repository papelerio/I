<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor de Imágenes - Quitafondos</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #mainContainer {
            display: flex;
            width: 100%;
            max-width: 1400px;
            gap: 20px;
        }
        #canvasContainer {
            flex: 1;
            position: relative;
            border: 2px solid #333;
            max-width: 800px;
        }
        #bgCanvas, #canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        #canvas {
            cursor: default;
        }
        #tools {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            width: 280px;
            display: flex;
            flex-direction: column;
        }
        button {
            margin: 5px 0;
            padding: 10px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #0056b3;
        }
        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }
        select {
            margin: 5px 0;
            padding: 8px;
        }
        label {
            margin: 5px 0;
            font-size: 14px;
        }
        #preview {
            border: 1px solid #ccc;
            margin: 5px 0;
            display: block;
        }
        #info {
            text-align: center;
            margin-top: 10px;
            color: #666;
            width: 100%;
        }
        h1 {
            width: 100%;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>Editor de Imágenes - Quitafondos (Chroma Key Simple)</h1>
    
    <div id="mainContainer">
        <div id="canvasContainer">
            <canvas id="bgCanvas" width="800" height="600"></canvas>
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>
        
        <div id="tools">
            <button id="pickColor">Identificar Color</button>
            <label>Intensidad: <span id="val">20</span>%</label>
            <input type="range" id="intensity" min="0" max="100" value="20">
            <canvas id="preview" width="250" height="188"></canvas>
            <button id="removeBg">Quitar Fondo</button>
            
            <label>Fondo de visualización:</label>
            <select id="bgSelect">
                <option value="white">Blanco</option>
                <option value="red">Rojo</option>
                <option value="blue">Azul</option>
                <option value="green">Verde</option>
            </select>
            
            <button id="brushBtn">Pincel (Restaurar)</button>
            <label>Tamaño del pincel: <span id="brushVal">20</span></label>
            <input type="range" id="brushSize" min="1" max="100" value="20">
            
            <button id="cropBtn">Cortar Rectángulo</button>
            
            <button id="undoBtn">Retroceder (Ctrl+Z)</button>
            <button id="export">Exportar como PNG</button>
        </div>
    </div>
    
    <p id="info">Arrastra una imagen al área o usa Ctrl+V para pegar. Haz clic en "Identificar color" y luego en el canvas para seleccionar el color de fondo.</p>

    <script>
        const container = document.getElementById('canvasContainer');
        const bgCanvas = document.getElementById('bgCanvas');
        const canvas = document.getElementById('canvas');
        const bgCtx = bgCanvas.getContext('2d');
        const ctx = canvas.getContext('2d');
        const origCanvas = document.createElement('canvas');
        const origCtx = origCanvas.getContext('2d');
        const previewEl = document.getElementById('preview');
        const previewCtx = previewEl.getContext('2d');

        let currentImageData, originalData;
        let history = [];
        let currentState = -1;
        let picking = false;
        let brushMode = false;
        let cropMode = false;
        let selectedColor = { r: 0, g: 0, b: 0 };
        let intensity = 20;
        let brushSize = 20;
        let bgColor = 'white';
        let painting = false;
        let isDragging = false;
        let startX, startY;

        // Configurar tamaño inicial
        canvas.width = 800;
        bgCanvas.width = 800;
        canvas.height = 600;
        bgCanvas.height = 600;
        origCanvas.width = 800;
        origCanvas.height = 600;
        updateBg();

        function updateBg() {
            bgCtx.fillStyle = bgColor;
            bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
        }

        function refreshPreview() {
            if (selectedColor.r === undefined || selectedColor.r === 0 && selectedColor.g === 0 && selectedColor.b === 0) {
                previewCtx.clearRect(0, 0, 250, 188);
                return;
            }
            const tempDataArr = currentImageData.data.slice(0);
            const threshold = (intensity / 100) * Math.sqrt(3 * 255 * 255);
            for (let i = 0; i < tempDataArr.length; i += 4) {
                const r = tempDataArr[i];
                const g = tempDataArr[i + 1];
                const b = tempDataArr[i + 2];
                const dist = Math.sqrt(
                    Math.pow(r - selectedColor.r, 2) +
                    Math.pow(g - selectedColor.g, 2) +
                    Math.pow(b - selectedColor.b, 2)
                );
                if (dist <= threshold) {
                    tempDataArr[i + 3] = 0;
                }
            }
            const tempImageData = new ImageData(tempDataArr, canvas.width, canvas.height);
            const tempCan = document.createElement('canvas');
            tempCan.width = canvas.width;
            tempCan.height = canvas.height;
            const tctx = tempCan.getContext('2d');
            tctx.putImageData(tempImageData, 0, 0);
            previewCtx.fillStyle = bgColor;
            previewCtx.fillRect(0, 0, 250, 188);
            previewCtx.drawImage(tempCan, 0, 0, 250, 188);
        }

        function applyRemoval(data, color, thresh) {
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const dist = Math.sqrt(
                    Math.pow(r - color.r, 2) +
                    Math.pow(g - color.g, 2) +
                    Math.pow(b - color.b, 2)
                );
                if (dist <= thresh) {
                    data[i + 3] = 0;
                }
            }
        }

        function saveState() {
            const w = canvas.width;
            const h = canvas.height;
            const currCopyData = new Uint8ClampedArray(currentImageData.data);
            const origCopyData = new Uint8ClampedArray(originalData.data);
            const currCopy = new ImageData(currCopyData, w, h);
            const origCopy = new ImageData(origCopyData, w, h);
            history[++currentState] = { w, h, current: currCopy, original: origCopy };
            while (history.length > currentState + 1) history.pop();
        }

        function undo() {
            if (currentState > 0) {
                const state = history[--currentState];
                canvas.width = state.w;
                bgCanvas.width = state.w;
                canvas.height = state.h;
                bgCanvas.height = state.h;
                origCanvas.width = state.w;
                origCanvas.height = state.h;
                ctx.putImageData(state.current, 0, 0);
                originalData = state.original;
                origCtx.putImageData(originalData, 0, 0);
                currentImageData = ctx.getImageData(0, 0, state.w, state.h);
                updateBg();
                refreshPreview();
                updateInfo('Acción deshecha.');
            }
        }

        function setCursor() {
            canvas.style.cursor = picking ? 'crosshair' : brushMode ? 'pointer' : cropMode ? 'crosshair' : 'default';
        }

        function updateInfo(message) {
            document.getElementById('info').textContent = message;
        }

        // Manejar pegado (Ctrl+V)
        document.addEventListener('paste', (e) => {
            const items = e.clipboardData.items;
            for (let item of items) {
                if (item.type.indexOf('image') !== -1) {
                    const blob = item.getAsFile();
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            canvas.width = img.width;
                            bgCanvas.width = img.width;
                            canvas.height = img.height;
                            bgCanvas.height = img.height;
                            origCanvas.width = img.width;
                            origCanvas.height = img.height;
                            ctx.drawImage(img, 0, 0);
                            currentImageData = ctx.getImageData(0, 0, img.width, img.height);
                            originalData = new ImageData(currentImageData.data.slice(0), img.width, img.height);
                            origCtx.putImageData(originalData, 0, 0);
                            updateBg();
                            saveState();
                            updateInfo('Imagen cargada. Selecciona un color para quitar el fondo.');
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(blob);
                    e.preventDefault();
                    break;
                }
            }
        });

        // Manejar arrastrar y soltar
        container.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        container.addEventListener('drop', (e) => {
            e.preventDefault();
            const files = e.dataTransfer.files;
            for (let file of files) {
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            canvas.width = img.width;
                            bgCanvas.width = img.width;
                            canvas.height = img.height;
                            bgCanvas.height = img.height;
                            origCanvas.width = img.width;
                            origCanvas.height = img.height;
                            ctx.drawImage(img, 0, 0);
                            currentImageData = ctx.getImageData(0, 0, img.width, img.height);
                            originalData = new ImageData(currentImageData.data.slice(0), img.width, img.height);
                            origCtx.putImageData(originalData, 0, 0);
                            updateBg();
                            saveState();
                            updateInfo('Imagen cargada. Selecciona un color para quitar el fondo.');
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(file);
                    break;
                }
            }
        });

        // Herramienta de identificar color
        document.getElementById('pickColor').addEventListener('click', () => {
            picking = true;
            brushMode = false;
            cropMode = false;
            setCursor();
            updateInfo('Haz clic en el canvas para seleccionar el color de fondo.');
        });

        canvas.addEventListener('click', (e) => {
            if (!picking) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const imageData = ctx.getImageData(x, y, 1, 1);
            const data = imageData.data;
            selectedColor = { r: data[0], g: data[1], b: data[2] };
            picking = false;
            setCursor();
            updateInfo(`Color seleccionado: RGB(${selectedColor.r}, ${selectedColor.g}, ${selectedColor.b}). Ajusta la intensidad y quita el fondo.`);
            refreshPreview();
        });

        // Barra de intensidad
        document.getElementById('intensity').addEventListener('input', (e) => {
            intensity = parseInt(e.target.value);
            document.getElementById('val').textContent = intensity;
            refreshPreview();
        });

        // Quitar fondo
        document.getElementById('removeBg').addEventListener('click', () => {
            if (selectedColor.r === 0 && selectedColor.g === 0 && selectedColor.b === 0) {
                alert('Primero selecciona un color con "Identificar Color".');
                return;
            }
            saveState();
            const threshold = (intensity / 100) * Math.sqrt(3 * 255 * 255);
            applyRemoval(currentImageData.data, selectedColor, threshold);
            ctx.putImageData(currentImageData, 0, 0);
            updateInfo('Fondo removido. Usa el pincel para restaurar áreas si es necesario.');
            refreshPreview();
        });

        // Fondo de visualización
        document.getElementById('bgSelect').addEventListener('change', (e) => {
            bgColor = e.target.value;
            updateBg();
            refreshPreview();
        });

        // Pincel
        document.getElementById('brushBtn').addEventListener('click', () => {
            brushMode = !brushMode;
            picking = false;
            cropMode = false;
            setCursor();
            updateInfo(brushMode ? 'Pincel activado. Dibuja sobre áreas transparentes para restaurar del original.' : 'Pincel desactivado.');
        });

        document.getElementById('brushSize').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            document.getElementById('brushVal').textContent = brushSize;
        });

        function paint(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const r = brushSize / 2;
            ctx.save();
            ctx.beginPath();
            ctx.arc(x, y, r, 0, 2 * Math.PI);
            ctx.clip();
            ctx.drawImage(origCanvas, 0, 0);
            ctx.restore();
            currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        }

        // Cortar rectángulo
        document.getElementById('cropBtn').addEventListener('click', () => {
            cropMode = !cropMode;
            picking = false;
            brushMode = false;
            setCursor();
            updateInfo(cropMode ? 'Arrastra para dibujar un rectángulo y cortar la imagen.' : 'Corte desactivado.');
        });

        // Eventos del mouse
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            if (brushMode) {
                painting = true;
                paint(e);
            } else if (cropMode) {
                isDragging = true;
                startX = x;
                startY = y;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            if (painting && brushMode) {
                paint(e);
            } else if (isDragging && cropMode) {
                ctx.putImageData(currentImageData, 0, 0);
                const x1 = Math.min(startX, x);
                const y1 = Math.min(startY, y);
                const width = Math.abs(x - startX);
                const height = Math.abs(y - startY);
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(x1, y1, width, height);
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            if (painting && brushMode) {
                painting = false;
                saveState();
                updateInfo('Área restaurada.');
            } else if (isDragging && cropMode) {
                ctx.putImageData(currentImageData, 0, 0); // Remover rect
                const x1 = Math.min(startX, x);
                const y1 = Math.min(startY, y);
                const cropWidth = Math.abs(x - startX);
                const cropHeight = Math.abs(y - startY);
                if (cropWidth < 10 || cropHeight < 10) {
                    isDragging = false;
                    return;
                }
                const cropX = Math.floor(x1);
                const cropY = Math.floor(y1);
                const newCurrentData = new ImageData(cropWidth, cropHeight);
                const newOriginalData = new ImageData(cropWidth, cropHeight);
                for (let dy = 0; dy < cropHeight; dy++) {
                    for (let dx = 0; dx < cropWidth; dx++) {
                        const srcX = cropX + dx;
                        const srcY = cropY + dy;
                        const dstIdx = (dy * cropWidth + dx) * 4;
                        if (srcX >= 0 && srcX < canvas.width && srcY >= 0 && srcY < canvas.height) {
                            const srcIdx = (srcY * canvas.width + srcX) * 4;
                            newCurrentData.data[dstIdx] = currentImageData.data[srcIdx];
                            newCurrentData.data[dstIdx + 1] = currentImageData.data[srcIdx + 1];
                            newCurrentData.data[dstIdx + 2] = currentImageData.data[srcIdx + 2];
                            newCurrentData.data[dstIdx + 3] = currentImageData.data[srcIdx + 3];
                            newOriginalData.data[dstIdx] = originalData.data[srcIdx];
                            newOriginalData.data[dstIdx + 1] = originalData.data[srcIdx + 1];
                            newOriginalData.data[dstIdx + 2] = originalData.data[srcIdx + 2];
                            newOriginalData.data[dstIdx + 3] = originalData.data[srcIdx + 3];
                        } else {
                            newCurrentData.data[dstIdx + 3] = 0;
                            newOriginalData.data[dstIdx + 3] = 0;
                        }
                    }
                }
                canvas.width = cropWidth;
                bgCanvas.width = cropWidth;
                canvas.height = cropHeight;
                bgCanvas.height = cropHeight;
                origCanvas.width = cropWidth;
                origCanvas.height = cropHeight;
                currentImageData = newCurrentData;
                originalData = newOriginalData;
                origCtx.putImageData(originalData, 0, 0);
                ctx.putImageData(currentImageData, 0, 0);
                updateBg();
                saveState();
                refreshPreview();
                updateInfo('Imagen cortada al rectángulo seleccionado.');
                isDragging = false;
            }
        });

        // Undo
        document.getElementById('undoBtn').addEventListener('click', undo);
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'z' && !e.repeat) {
                undo();
            }
        });

        // Exportar como PNG
        document.getElementById('export').addEventListener('click', () => {
            const temp = document.createElement('canvas');
            temp.width = canvas.width;
            temp.height = canvas.height;
            const tctx = temp.getContext('2d');
            tctx.putImageData(currentImageData, 0, 0);
            const link = document.createElement('a');
            link.download = 'imagen_sin_fondo.png';
            link.href = temp.toDataURL('image/png');
            link.click();
            updateInfo('Imagen exportada como PNG con transparencia.');
        });

        // Inicial
        updateInfo('Carga una imagen para comenzar.');
    </script>
</body>
</html>
